"""
post_process_dsl.py - Post-process pystructurizr DSL output

This script takes the DSL generated by pystructurizr and adds:
- Workspace name and description
- !identifiers flat directive
- Custom terminology (Team/Platform/Application)
- Themes and branding
- Relationship identifiers for cross-workspace references
- Any other custom Structurizr DSL features
"""

import sys
import re
from pathlib import Path


class DSLPostProcessor:
    """Post-processes Structurizr DSL files with custom enhancements."""
    
    def __init__(self):
        self.workspace_name = "Channel 4 Core"
        self.workspace_description = "Base Line Model"
        # URLs point to synchrotron/c4c4 repo
        self.theme_url = "https://raw.githubusercontent.com/synchrotron/c4c4/main/assets/c4-default-theme.json"
        self.logo_url = "https://raw.githubusercontent.com/synchrotron/c4c4/main/assets/4-logo-black.png"
        self.font_name = "4Text"
        self.font_url = "https://raw.githubusercontent.com/synchrotron/c4c4/main/assets/4Text-Regular.ttf"
    
    def read_file(self, input_file):
        """Read the input DSL file."""
        with open(input_file, 'r', encoding='utf-8') as f:
            return f.read()
    
    def write_file(self, output_file, content):
        """Write the processed DSL file."""
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(content)
    
    def add_workspace_wrapper(self, content):
        """
        Wrap the content with workspace declaration.
        Assumes the input starts with 'model {' or 'views {'
        """
        # Remove any existing workspace wrapper if present
        content = re.sub(r'^workspace\s*{', '', content, flags=re.MULTILINE)
        content = content.rstrip().rstrip('}')
        
        wrapped = f'workspace "{self.workspace_name}" "{self.workspace_description}" {{\n'
        wrapped += '\n    !identifiers flat\n'
        wrapped += '\n'
        wrapped += self.indent_content(content, 1)
        wrapped += '\n}'
        
        return wrapped
    
    def add_archetypes(self, content):
        """
        Add the archetypes block after the model opening.
        This maps 'application' to 'container' semantically.
        """
        # Find the model { line and insert archetypes after it
        pattern = r'(model\s*{)'
        replacement = r'\1\n    \n    archetypes {\n        application = container\n    }'
        
        return re.sub(pattern, replacement, content, count=1)
    
    def add_views_enhancements(self, content):
        """
        Add terminology, themes, and branding to the views section.
        """
        # Find the views { line
        views_pattern = r'(views\s*{)'
        
        enhancements = '''
        
        terminology {
            person "Team"
            softwareSystem "Platform"
            container "Application"
        }
        
        themes ''' + self.theme_url + '''
        
        branding {
            logo ''' + self.logo_url + '''
            font "''' + self.font_name + '''" ''' + self.font_url + '''
        }'''
        
        replacement = r'\1' + enhancements
        
        return re.sub(views_pattern, replacement, content, count=1)
    
    def remove_styles_section(self, content):
        """
        Remove the entire styles section from the views block.
        This prevents conflicts with the applied theme.
        """
        # Remove styles { ... } block including all nested content
        # This regex handles nested braces properly
        lines = content.split('\n')
        result_lines = []
        in_styles_block = False
        brace_count = 0
        styles_start_indent = 0
        
        for line in lines:
            # Check if we're starting a styles block
            if re.match(r'\s*styles\s*\{', line):
                in_styles_block = True
                styles_start_indent = len(line) - len(line.lstrip())
                brace_count = 1
                continue
            
            # If we're in a styles block, track braces
            if in_styles_block:
                brace_count += line.count('{')
                brace_count -= line.count('}')
                
                # If braces are balanced, we've finished the styles block
                if brace_count == 0:
                    in_styles_block = False
                continue
            
            # If not in styles block, keep the line
            result_lines.append(line)
        
        return '\n'.join(result_lines)
    
    def add_relationship_identifiers(self, content):
        """
        Add identifiers to relationships so they can be referenced in other workspaces.
        Converts: person1 -> person2 "description"
        To: person1ToPerson2 = person1 -> person2 "description"
        """
        lines = content.split('\n')
        result_lines = []
        
        # Pattern to match relationship lines
        # Matches: source -> destination "description" "technology" "tags"
        relationship_pattern = r'^(\s*)(\w+)\s+->\s+(\w+)\s+(.*)$'
        
        for line in lines:
            match = re.match(relationship_pattern, line)
            if match:
                indent = match.group(1)
                source = match.group(2)
                destination = match.group(3)
                rest = match.group(4)
                
                # Create identifier from source and destination
                # Convert to camelCase: ebs -> wda becomes ebsToWda
                identifier = f"{source}To{destination[0].upper()}{destination[1:]}"
                
                # Reconstruct line with identifier
                new_line = f"{indent}{identifier} = {source} -> {destination} {rest}"
                result_lines.append(new_line)
            else:
                result_lines.append(line)
        
        return '\n'.join(result_lines)
    
    def indent_content(self, content, levels=1):
        """Add indentation to content."""
        indent = '    ' * levels
        lines = content.split('\n')
        return '\n'.join(indent + line if line.strip() else line for line in lines)
    
    def add_comments(self, content):
        """Add helpful comments to the DSL."""
        # Add header comment
        header = """/*
 * Channel 4 Core Architecture Model
 * Generated by pystructurizr and post-processed
 * 
 * This workspace defines the core platforms and applications
 * used across Channel 4's enterprise architecture.
 */

"""
        return header + content
    
    def process(self, input_file, output_file=None):
        """
        Main processing pipeline.
        
        Args:
            input_file: Path to the input DSL file from pystructurizr
            output_file: Path to save the processed DSL (defaults to input_file)
        """
        if output_file is None:
            output_file = input_file
        
        print(f"Reading {input_file}...")
        content = self.read_file(input_file)
        
        print("Processing DSL...")
        
        # Apply transformations in order
        content = self.add_workspace_wrapper(content)
        content = self.add_archetypes(content)
        content = self.remove_styles_section(content)
        content = self.add_views_enhancements(content)
        content = self.add_relationship_identifiers(content)
        content = self.add_comments(content)
        
        print(f"Writing to {output_file}...")
        self.write_file(output_file, content)
        
        print("✓ Post-processing complete!")
        print(f"\nEnhancements added:")
        print("  ✓ Workspace name and description")
        print("  ✓ !identifiers flat directive")
        print("  ✓ Archetypes (application = container)")
        print("  ✓ Custom terminology (Team/Platform/Application)")
        print("  ✓ Theme URL")
        print("  ✓ Branding (logo and font)")
        print("  ✓ Documentation comments")
        print("  ✓ Removed styles section (using theme instead)")
        print("  ✓ Added relationship identifiers for cross-workspace references")


def main():
    """CLI entry point."""
    
    if len(sys.argv) < 2:
        print("Usage: python post_process_dsl.py <input_dsl_file> [output_dsl_file]")
        print("\nExample:")
        print("  python post_process_dsl.py raw_output.dsl c4-core-workspace.dsl")
        print("\nOr process in-place:")
        print("  python post_process_dsl.py c4-core-workspace.dsl")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else input_file
    
    if not Path(input_file).exists():
        print(f"Error: Input file '{input_file}' not found!")
        sys.exit(1)
    
    print("=" * 70)
    print("Structurizr DSL Post-Processor")
    print("=" * 70)
    print()
    
    processor = DSLPostProcessor()
    processor.process(input_file, output_file)
    
    print()
    print("=" * 70)
    print(f"Processed DSL saved to: {output_file}")
    print("You can now upload this to Structurizr!")
    print("=" * 70)


if __name__ == "__main__":
    main()